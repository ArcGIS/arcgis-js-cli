import{a5 as e,dI as t,dJ as n,dK as a,k as l,aT as o,dL as s,bY as i,aF as r,bE as c,a as u}from"../main.js";const h=function(e,t){const n=(e.isWGS84||e.isWebMercator)&&(t.isWGS84||t.isWebMercator);return!(e.equals(t)||n)};async function x(){if(t()||!n())return null;await a()}function f(e,n,a,r=null){if(e.spatialReference.equals(n))return e;const c=h(e.spatialReference,n);if(c&&!t())throw new l("rasterprojectionhelper-projectResolution","projection engine is not loaded");const u=a.center,x=new o({xmin:u.x-e.x/2,xmax:u.x+e.x/2,ymin:u.y-e.y/2,ymax:u.y+e.y/2,spatialReference:e.spatialReference}),f=c?s(x,n,r):i(x,n);return null==f?null:{x:f.xmax-f.xmin,y:f.ymax-f.ymin}}function m(e,t=.01){return c(e)?t/c(e):0}function p(e,n,a=null,o=!0){const c=e.spatialReference;if(c.equals(n))return e;const u=h(c,n);if(u&&!t())throw new l("rasterprojectionhelper-projectResolution","projection engine is not loaded");const x=u?s(e,n,a):i(e,n);if(x&&o&&n.isGeographic){var f,p;const[t,n]=c.isWebMercator?r(c).origin:null!=(f=null==(p=r(c))?void 0:p.valid)?f:[],a=m(c);a&&null!=t&&null!=n&&(Math.abs(e.x-t)<a&&Math.abs(180-x.x)<5e-4?x.x-=360:Math.abs(e.x-n)<a&&Math.abs(180+x.x)<5e-4&&(x.x+=360))}return x}function d(n,a,o=null,c=!0){var u,x,f,d;const y=n.spatialReference;if(y.equals(a))return n;const M=h(y,a);if(M&&!t())throw new l("rasterprojectionhelper-projectExtent","projection engine is not loaded");const g=M?s(n,a,o):i(n,a);let[w,R]=null!=(u=null==(x=r(y))?void 0:x.origin)?u:[];if(g&&c&&y.isWebMercator&&a.isGeographic&&null!=w&&null!=R){const t=.001,l=1e3;if(Math.abs(n.xmin-w)<t&&Math.abs(R-n.xmax)>l&&Math.abs(180-g.xmax)<5e-4){g.xmin=-180;const t=[];t.push(new e(n.xmax,n.ymin,y)),t.push(new e(n.xmax,(n.ymin+n.ymax)/2,y)),t.push(new e(n.xmax,n.ymax,y));const l=t.map((e=>p(e,a,o))).filter((e=>!isNaN(null==e?void 0:e.x))).map((e=>e.x));g.xmax=Math.max.apply(null,l)}if(Math.abs(n.xmax-R)<t&&Math.abs(w-n.xmin)>l&&Math.abs(180+g.xmin)<5e-4){g.xmax=180;const t=[];t.push(new e(n.xmin,n.ymin,y)),t.push(new e(n.xmin,(n.ymin+n.ymax)/2,y)),t.push(new e(n.xmin,n.ymax,y));const l=t.map((e=>p(e,a,o))).filter((e=>!isNaN(null==e?void 0:e.x))).map((e=>e.x));g.xmin=Math.min.apply(null,l)}}[w,R]=a.isWebMercator?r(a).origin:null!=(f=null==(d=r(a))?void 0:d.valid)?f:[];const b=m(a);return b&&null!=w&&null!=R&&(Math.abs(g.xmin-w)<b&&(g.xmin=w),Math.abs(g.xmax-R)<b&&(g.xmax=R)),g}function y(n,a,o,s=null,i=null,c=!1,u=[32,32]){var x,f;if(h(n.spatialReference,a.spatialReference)&&!t())throw new l("rasterprojectionhelper-projectResolution","projection engine is not loaded");if(!(n&&a&&o))return null;const{xmin:m,ymin:d,xmax:y,ymax:M}=n,g=n.spatialReference,w=a.spatialReference,[R,b]=null!=(x=null==(f=r(g))?void 0:f.valid)?x:[],v={x:u[0]*o.x,y:u[1]*o.y},k={cols:Math.ceil((y-m)/v.x-.1)+1,rows:Math.ceil((M-d)/v.y-.1)+1},_=v.x,B=v.y,z=[];let j,C=!1;for(let t=0;t<k.cols;t++){const n=[];for(let l=0;l<k.rows;l++){let o=p(new e({x:m+_*t,y:M-B*l,spatialReference:g}),w,s);i&&(o=i.inverseTransform(o)),n.push(o),t>0&&c&&o&&j[l]&&null!=R&&o.x<j[l].x&&(o.x+=b-R),o?(z.push((o.x-a.xmin)/(a.xmax-a.xmin)),z.push((a.ymax-o.y)/(a.ymax-a.ymin))):(z.push(NaN),z.push(NaN),C=!0)}j=n}const N=function(e,t){const n=(e[0]+e[4]+e[4*t.cols]+e[4*t.cols+4])/4,a=(e[1]+e[5]+e[4*t.rows+1]+e[4*t.rows+5])/4;return[Math.abs(n-e[2*t.rows+2]),Math.abs(a-e[2*t.rows+3])]}(z,k),S=new Float32Array((k.cols-1)*(k.rows-1)*2*6),W=new Float32Array([-0,-1,1,-1,1,-0,1,-0,-0]),I=new Float32Array([-1,1,0,0,-1,1,1,0,0]);for(let e=0;e<k.cols-1;e++){for(let t=0;t<k.rows-1;t++){let n=e*k.rows*2+2*t;const a=z[n],l=z[n+1],o=z[n+2],s=z[n+3];n+=2*k.rows;const i=z[n],r=z[n+1],c=z[n+2],u=z[n+3];let h=0,x=12*(t*(k.cols-1)+e);for(let e=0;e<3;e++)S[x++]=W[h++]*a+W[h++]*o+W[h++]*c;h=0;for(let e=0;e<3;e++)S[x++]=W[h++]*l+W[h++]*s+W[h++]*u;h=0;for(let e=0;e<3;e++)S[x++]=I[h++]*a+I[h++]*i+I[h++]*c;h=0;for(let e=0;e<3;e++)S[x++]=I[h++]*l+I[h++]*r+I[h++]*u}if(C)for(let e=0;e<S.length;e++)isNaN(S[e])&&(S[e]=-1)}return{offsets:z,error:N,coefficients:S,spacing:u,size:[k.cols-1,k.rows-1]}}function M(t,n,a){const l=Math.log(t.x/n.pixelSize.x)/Math.LN2,o=Math.log(t.y/n.pixelSize.y)/Math.LN2,s=n.storageInfo.maximumPyramidLevel||0;let i="down"===a?Math.floor(Math.min(l,o)):"up"===a?Math.ceil(Math.max(l,o)):Math.round((l+o)/2),r=!1;i<0?i=0:i>s&&(r=i>s+3,i=s);const c=Math.pow(2,i);return{pyramidLevel:i,pyramidResolution:new e({x:c*n.nativePixelSize.x,y:c*n.nativePixelSize.y,spatialReference:n.spatialReference}),excessiveReading:r}}function g(t,n,a=512,l=!0){const{extent:o,spatialReference:s,pixelSize:i}=t,r=f(new e({x:i.x,y:i.y,spatialReference:s}),n,o);if(null==r)return{projectedPixelSize:null,scales:null,srcResolutions:null};const u=(r.x+r.y)/2,h=c(n),x=u*h*96*39.37,m=n.isGeographic?512/a*295828763.7958547:512/a*591657527.591555;let p=!1;if(l&&(n.isGeographic||n.isWebMercator)){const e=d(o,n);p=e.xmin*e.xmax<0}let y,M=x;if(p){M=m;const t=M/(96*h*39.37);y=f(new e({x:t,y:t,spatialReference:n}),s,o)}else{y={x:i.x,y:i.y};const e=Math.ceil(Math.log(Math.min(t.width,t.height)/32)/Math.LN2);let n=0;for(;M<.5005*m&&n<e;)n++,M*=2,y.x*=2,y.y*=2;Math.max(M,m)/Math.min(M,m)<=1.001&&(M=m)}const g=[],w=[],R=Math.min(70.5310735,x)/1.001;for(;M>=R;)g.push(M),w.push({x:y.x,y:y.y}),M/=2,y.x/=2,y.y/=2;return{projectedPixelSize:r,scales:g,srcResolutions:w}}const w=new Map,R=new class{constructor(e=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const n=e+"/"+t,a=this._cachedBlocks;if(a.has(n)){const e=a.get(n);return e.refCount--,e.refCount<=0&&(a.delete(n),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const n=e+"/"+t,a=this._cachedBlocks;if(a.has(n)){const e=a.get(n);return e.ts=Date.now(),e.refCount++,a.delete(n),a.set(n,e),e.block}return null}putBlock(e,t,n,a=null){const l=this._cachedBlocks,o=e+"/"+t;if(l.has(o)){const e=l.get(o);e.ts=Date.now(),e.refCount++}else l.set(o,{block:n,ts:Date.now(),refCount:1,controller:a});this.trim(),this.updateTimer()}deleteBlock(e,t){const n=this._cachedBlocks,a=e+"/"+t;n.has(a)&&n.delete(a)}updateMaxSize(e){this._size=e,this.trim()}empty(){this._cachedBlocks.clear(),this.clearTimer()}getCurrentSize(){return this._cachedBlocks.size}updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval((()=>{const t=Array.from(e),n=Date.now();for(let a=0;a<t.length&&t[a][1].ts<=n-this._duration;a++)e.delete(t[a][0]);0===e.size&&this.clearTimer()}),this._interval)}trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let n=0;n<t.length-this._size;n++)e.delete(t[n][0])}clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function b(e,t){return null==t?e:`${e}?sliceId=${t}`}function v(e,t){const n={extent:null,rasterInfo:t,cache:new Map};if(w.has(e)){const t=w.get(e);return t.push(n),t.length-1}return w.set(e,[n]),0}function k(e,t){w.has(e)&&(w.get(e)[t]=null)}function _(e,t,n){if(!w.has(e))return null==t?R.decreaseRefCount(e,n):0;const a=w.get(e);if(null==a[t])return R.decreaseRefCount(e,n);const l=a[t].cache;if(l.has(n)){const e=l.get(n);if(e.refCount--,0===e.refCount){l.delete(n);for(let e=0;e<a.length;e++)a[e]&&a[e].cache.has(n)&&a[e].cache.delete(n);e.controller&&e.controller.abort()}return e.refCount}return 0}function B(e,t,n){if(!w.has(e))return null==t?R.getBlock(e,n):null;const a=w.get(e);if(null==a[t]){for(let e=0;e<a.length;e++)if(a[e]&&a[e].cache.has(n)){const t=a[e].cache.get(n);return t.refCount++,t.block}return R.getBlock(e,n)}const l=a[t].cache;if(l.has(n)){const e=l.get(n);return e.refCount++,e.block}for(let e=0;e<a.length;e++)if(e!==t&&a[e]&&a[e]&&a[e].cache.has(n)){const t=a[e].cache.get(n);return t.refCount++,l.set(n,t),t.block}return null}function z(e,t,n,a,l=null){if(!w.has(e))return void(null==t&&R.putBlock(e,n,a,l));const o=w.get(e);if(null==o[t])return void R.putBlock(e,n,a,l);const s={refCount:1,block:a,isResolved:!1,isRejected:!1,controller:l};a.then((()=>s.isResolved=!0)).catch((()=>s.isRejected=!0)),o[t].cache.set(n,s)}function j(e,t,n){if(!w.has(e))return void(null==t&&R.deleteBlock(e,n));const a=w.get(e);null!=a[t]?a[t].cache.delete(n):R.deleteBlock(e,n)}function C(t,n,a,l,o,s,i=null){const r=function(e,t){if(!w.has(e))return null;const n=w.get(e);return null==n[t]?null:n[t]}(t,n),c=r.extent,{cache:h,rasterInfo:x}=r;if(c&&c.xmin===a.xmin&&c.xmax===a.xmax&&c.ymin===a.ymin&&c.ymax===a.ymax)return;const m=a.clone().normalize(),{spatialReference:p,transform:y}=x,g=new Set;for(let t=0;t<m.length;t++){const n=m[t];if(n.xmax-n.xmin<=l||n.ymax-n.ymin<=l)continue;let a=d(n,p,i);u(y)&&(a=y.inverseTransform(a));const r=new e({x:l,y:l,spatialReference:n.spatialReference});if(null===o&&!(o=f(r,p,n,i)))return;const{pyramidLevel:c,pyramidResolution:h,excessiveReading:w}=M(o,x,s||"closest");if(w)return;const{storageInfo:R}=x,{origin:b}=R,v={x:Math.max(0,Math.floor((a.xmin-b.x)/h.x)),y:Math.max(0,Math.floor((b.y-a.ymax)/h.y))},k=Math.ceil((a.xmax-a.xmin)/h.x-.1),_=Math.ceil((a.ymax-a.ymin)/h.y-.1),B=c>0?R.pyramidBlockWidth:R.blockWidth,z=c>0?R.pyramidBlockHeight:R.blockHeight,j=1,C=Math.max(0,Math.floor(v.x/B)-j),N=Math.max(0,Math.floor(v.y/z)-j),S=Math.floor((v.x+k-1)/B)+j,W=Math.floor((v.y+_-1)/z)+j;for(let e=N;e<=W;e++)for(let t=C;t<=S;t++)g.add(`${c}/${e}/${t}`)}h.forEach(((e,t)=>{if(!g.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}})),r.extent={xmin:a.xmin,ymin:a.ymin,xmax:a.xmax,ymax:a.ymax}}export{y as M,C as a,x as b,j as c,g as d,_ as e,p as h,b as i,B as m,f as p,v as s,k as u,M as w,z as x,d as y};
