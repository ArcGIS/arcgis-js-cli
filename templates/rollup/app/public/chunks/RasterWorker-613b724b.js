import{aT as t,U as e}from"../main.js";import"./LercCodec-6bf6a7c3.js";import{u as s,o as r,A as o,c as i,U as l}from"./pixelUtils-6e86d48c.js";import{U as m,R as c}from"./RasterSymbolizer-b4394874.js";export default class{async decode(t){const e=await m(t.data,t.options);return e&&e.toJSON()}symbolize(r){r.pixelBlock=s.fromJSON(r.pixelBlock),r.extent=r.extent?t.fromJSON(r.extent):null;const o=this.symbolizer.symbolize(r);return e(o&&o.toJSON())}async updateSymbolizer(t){var e;this.symbolizer=c.fromJSON(t.symbolizerJSON),t.histograms&&"rasterStretch"===(null==(e=this.symbolizer)?void 0:e.rendererJSON.type)&&(this.symbolizer.rendererJSON.histograms=t.histograms)}stretch(t){const r=this.symbolizer.simpleStretch(s.fromJSON(t.srcPixelBlock),t.stretchParams);return e(r&&r.toJSON())}estimateStatisticsHistograms(t){const o=r(s.fromJSON(t.srcPixelBlock));return e(o)}split(t){const r=o(s.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel);return r&&r.forEach(((t,e)=>{r.set(e,null==t?void 0:t.toJSON())})),e(r)}async mosaicAndTransform(t){const e=t.srcPixelBlocks.map((t=>t?new s(t):null)),r=i(e,t.srcMosaicSize);if(!t.coefs)return r&&r.toJSON();const o=l(r,t.destDimension,t.coefs,t.sampleSpacing,t.interpolation);return o&&o.toJSON()}}
