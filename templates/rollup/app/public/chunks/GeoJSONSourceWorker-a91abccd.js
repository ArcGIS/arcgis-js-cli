import{L as e,d_ as t,k as i,er as s,es as n,a_ as r,bs as a,v as o,ak as l}from"../main.js";import{K as d,Q as u,D as p,J as y,B as c}from"./featureConversionUtils-0e5f7c52.js";import"./centroid-aa1305d6.js";import"./WhereClause-5e802398.js";import"./json-9a5f5790.js";import{g as f,f as m}from"./quantizationUtils-779d11a7.js";import{i as h,u as g,h as b,s as I}from"./FeatureStore-0230fecd.js";import"./aaBoundingBox-56c013d2.js";import"./quickselect-efd045df.js";import"./QueryEngineCapabilities-84134205.js";import"./ItemCache-710ba6c9.js";import{b as F}from"./QueryEngine-3285a5ce.js";import"./timeSupport-8b9f8b97.js";import{h as _,w as j,b as E}from"./geojson-32554284.js";import{y as T,d as q,c as x,u as w,h as D}from"./sourceUtils-96139ca0.js";const R={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};export default class{constructor(){this._queryEngine=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._requiredFields=this._fieldsIndex=this._createDefaultAttributes=null}async load(o){const l=[];await this._checkProjection(o.spatialReference);let p=null;o.url&&(p=(await e(o.url,{responseType:"json"})).data,await _(p));const y=j(p,{geometryType:o.geometryType}),c=o.fields||y.fields||[],m=null!=o.hasZ?o.hasZ:y.hasZ,T=y.geometryType,q=o.objectIdField||("number"===y.objectIdFieldType?y.objectIdFieldName:"OBJECTID")||"OBJECTID",x=o.spatialReference||t;let w=o.timeInfo;if(!T)throw new i("geojson-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if("string"===y.objectIdFieldType&&l.push({name:"geojson-layer:unsupported-id-type",message:"Feature ids are of type string and can't be honored."}),c===y.fields&&y.unknownFields.length>0&&l.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:y.unknownFields}}),q){let e=null;c.some((t=>t.name===q&&(e=t,!0)))?(e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):c.unshift({alias:q,name:q,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const e of c){if(null==e.name&&(e.name=e.alias),null==e.alias&&(e.alias=e.name),!e.name)throw new i("geojson-layer:invalid-field-name","field name is missing",{field:e});if(e.name===q&&(e.type="esriFieldTypeOID"),-1===s.jsonValues.indexOf(e.type))throw new i("geojson-layer:invalid-field-type",`invalid type for field "${e.name}"`,{field:e})}const D={};this._requiredFields=[];for(const e of c)if("esriFieldTypeOID"!==e.type&&"esriFieldTypeGlobalID"!==e.type){e.editable=null==e.editable||!!e.editable,e.nullable=null==e.nullable||!!e.nullable;const t=n(e);e.nullable||void 0!==t?D[e.name]=t:this._requiredFields.push(e)}if(this._fieldsIndex=new r(c),w){if(w.startTimeField){const e=this._fieldsIndex.get(w.startTimeField);e?(w.startTimeField=e.name,e.type="esriFieldTypeDate"):w.startTimeField=null}if(w.endTimeField){const e=this._fieldsIndex.get(w.endTimeField);e?(w.endTimeField=e.name,e.type="esriFieldTypeDate"):w.endTimeField=null}if(w.trackIdField){const e=this._fieldsIndex.get(w.trackIdField);e?w.trackIdField=e.name:(w.trackIdField=null,l.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:w}}))}w.startTimeField||w.endTimeField||(l.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:w}}),w=null)}const O={warnings:l,featureErrors:[],layerDefinition:{...R,drawingInfo:h(T),templates:g(D),extent:null,geometryType:T,objectIdField:q,fields:c,hasZ:!!m,timeInfo:w}};this._queryEngine=new F({fields:c,geometryType:T,hasM:!1,hasZ:m,objectIdField:q,spatialReference:x,timeInfo:w,featureStore:new b({geometryType:T,hasM:!1,hasZ:m})}),this._createDefaultAttributes=I(D,q),this._nextObjectId=y.maxObjectId+1;const k=E(p,{geometryType:T,hasZ:m,objectIdFieldName:"number"===y.objectIdFieldType?q:null});if(!a(x,t))for(const e of k)e.geometry&&(e.geometry=d(f(u(e.geometry,T,m,!1),t,x)));return this._loadInitialFeatures(O,k),O}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await o([T(t,i),m(e.adds,t),m(e.updates,t)]),this._applyEdits(e)}async queryFeatures(e={},t={}){return this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}_loadInitialFeatures(e,t){const{featureStore:i,objectIdField:s}=this._queryEngine,n=[];for(const i of t){const t=this._createDefaultAttributes(),r=q(this._fieldsIndex,this._requiredFields,t,i.attributes,!0,e.warnings);r?e.featureErrors.push(r):(this._assignObjectId(t,i.attributes,!0),i.attributes=t,i.objectId=t[s],n.push(i))}if(i.addMany(n),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:t,end:i}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}_applyEdits(e){const{adds:t,updates:i,deletes:s}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(n,t),i&&i.length&&this._applyUpdateEdits(n,i),s&&s.length){for(const e of s)n.deleteResults.push(x(e));this._queryEngine.featureStore.removeManyById(s)}return{fullExtent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:n,hasZ:r,objectIdField:a,spatialReference:o,featureStore:d}=this._queryEngine,u=[];for(const n of t){if(n.geometry&&s!==l(n.geometry)){i.push(w("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),r=q(this._fieldsIndex,this._requiredFields,t,n.attributes);if(r)i.push(r);else{if(this._assignObjectId(t,n.attributes),n.attributes=t,null!=n.uid){const t=n.attributes[a];e.uidToObjectId[n.uid]=t}n.geometry&&(n.geometry=f(D(n.geometry,o),n.geometry.spatialReference,o)),u.push(n),i.push(x(n.attributes[a]))}}d.addMany(p([],u,s,r,n,a))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:a,featureStore:o}=this._queryEngine;for(const d of t){const{attributes:t,geometry:u}=d,p=t&&t[r];if(null==p){e.push(w(`Identifier field ${r} missing`));continue}if(!o.has(p)){e.push(w(`Feature with object id ${p} missing`));continue}const m=y(o.getFeature(p),i,n,s);if(u){if(i!==l(u)){e.push(w("Incorrect geometry type."));continue}m.geometry=f(D(u,a),u.spatialReference,a)}if(t){const i=q(this._fieldsIndex,this._requiredFields,m.attributes,t);if(i){e.push(i);continue}}o.add(c(m,i,n,s,r)),e.push(x(p))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}async _checkProjection(e){try{await m(t,e)}catch{throw new i("geojson-layer","Projection not supported")}}}
