import{i as e,p as t,q as r,aX as s,dW as i,x as a,af as o,aB as n,a$ as c,b0 as l,t as d,a as h,T as m}from"../main.js";import"./featureConversionUtils-0e5f7c52.js";import"./centroid-aa1305d6.js";import"./FeatureSetReader-b7349ae0.js";import"./json-9a5f5790.js";import"./quantizationUtils-779d11a7.js";import"./quickselect-efd045df.js";import{C as u}from"./ComputedAttributeStorage-82041b67.js";import{o as g,g as p}from"./definitions-5e24d82a.js";import"./RenderingContext-81847018.js";import"./Utils-b46864a6.js";import"./CircularArray-e829d2b1.js";import"./visualVariablesUtils-a8352e1b.js";import"./TurboLine-c366e7cd.js";import"./Rect-31175b04.js";import"./GeometryUtils-2b0c8e16.js";import"./BidiEngine-b37d0381.js";import"./MaterialKey-a89f5ca3.js";import{n as y}from"./shapingUtils-e86a3b68.js";import{s as f,m as _,t as b,L as j}from"./WGLMeshFactory-05a88f56.js";import"./VertexBuffer-06b50273.js";import"./MD5-f399cfb7.js";import{p as S}from"./BaseProcessor-823d1bfc.js";class v{constructor(e,t=2){this._bucketSize=e,this._rowsLength=g/e,this._colsLength=g/e,this._elementsPerBucket=t,this._grid=this._initGrid()}checkOverlap(e,t){const r=Math.floor(e/this._bucketSize),s=Math.floor(t/this._bucketSize);return r<0||r>=this._rowsLength||s<0||s>=this._colsLength||this._grid[s*this._colsLength+r]>=this._elementsPerBucket}markUsed(e,t){const r=Math.floor(e/this._bucketSize),s=Math.floor(t/this._bucketSize);this._grid[s*this._colsLength+r]+=1}reset(){this._grid=this._initGrid()}_initGrid(){return new Uint8Array(this._rowsLength*this._colsLength)}}e.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");let w=class extends S{constructor(){super(...arguments),this.type="symbol"}destroy(){}get supportsTileUpdates(){return!0}async update(e,t){const r=t.schema.processors[0];if("symbol"!==r.type)return;const o=s(this._schema,r);i(o,"mesh")&&(a("esri-2d-update-debug")&&console.debug("Applying Update - Processor:",o),e.mesh=!0,e.why.mesh.push("Symbology changed"),this._schema=r,this._factory=this._createFactory(r),this._factory.update(r,this.tileStore.tileScheme.tileInfo))}onTileData(e,t,r){return o(r),this._onTileData(e,t,r)}onTileError(e,t,r){const s=r.signal,i={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:s})}_createFactory(e){const{geometryType:t,objectIdField:r,fields:s}=this.service,i={geometryType:t,fields:s,spatialReference:n.fromJSON(this.spatialReference)},a=new j(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),!1);return this._store=a,this._matcher=f(e.mesh.matcher,a,i),new _(t,r,a)}async _onTileData(e,t,r){const{type:s,addOrUpdate:i,remove:a,end:n}=t;if(!i){const t={type:s,addOrUpdate:null,remove:a,clear:!1,end:n};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const d=this._processFeatures(e,i,r),h=r.signal;try{const t=await d,r=c(t,(e=>e.message)),i=c(t,(e=>e.transferList))||[],m={type:s,addOrUpdate:r,remove:a,clear:!1,end:n},u={transferList:l(i)||[],signal:h};return o(u),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:m},u)}catch(t){this._handleError(e,t,r)}}async _processFeatures(e,t,r){if(d(t)||!t.hasFeatures)return null;const s={transform:e.transform,hasZ:!1,hasM:!1},i=this._factory,a={viewingMode:"",scale:e.scale},n=await this._matcher;o(r);const c=this._getLabelInfos(e,t);return await i.analyze(t.getCursor(),n,s,a),o(r),this._writeFeatureSet(e,t,s,c,i)}_writeFeatureSet(e,t,r,s,i){const a=i.createMeshData(t.getApproximateSize()),o={viewingMode:"",scale:e.scale},n=t.getCursor();for(;n.next();)try{const t=n.getDisplayId(),c=h(s)?s.get(t):null;i.writeCursor(a,n,r,o,e.level,c)}catch(e){}return this._encodeDisplayData(a)}_encodeDisplayData(e){const t={},r=new Array;return e.encode(t,r),{message:t,transferList:r}}_handleError(e,t,r){if(!m(t)){const s={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}}_shouldDiscard(e,t){switch(this.service.geometryType){case"esriGeometryPoint":{const r=t.readLegacyPointGeometry();return!r||e.checkOverlap(r.x,r.y)}case"esriGeometryPolygon":{const r=t.readLegacyCentroid();return!r||e.checkOverlap(r.x,r.y)}default:return!1}}_markUsed(e,t){switch(this.service.geometryType){case"esriGeometryPoint":{const{x:r,y:s}=t.readLegacyPointGeometry();return e.markUsed(r,s)}case"esriGeometryPolygon":{const{x:r,y:s}=t.readLegacyCentroid();return e.markUsed(r,s)}}}_getLabelInfos(e,t){const r=this._schema.mesh.labels,s=c(r,(t=>t.filter((t=>function(e,t){return(!e.minScale||e.minScale>=t)&&(!e.maxScale||e.maxScale<=t)}(t,e.scale)))));if(d(s)||0===s.length)return null;const i=new Map,a=new v(p),o=t.getCursor();for(;o.next();){const e=o.getDisplayId();if(this._shouldDiscard(a,o)){i.has(e)||i.set(e,null);continue}let t=!1;const r=[],n=u(e),c=n&&1!==o.readAttribute("cluster_count")?"aggregate":"feature";for(const i of s){if(i.target!==c)continue;const s=o.getStorage(),a=n&&"feature"===c?s.getComputedStringAtIndex(o.readAttribute("referenceId"),i.fieldIndex):s.getComputedStringAtIndex(e,i.fieldIndex);if(!a)continue;const l=y(a.toString()),d=l[0],h=l[1];this._store.getMosaicItem(i.symbol,b(d)).then((e=>{r[i.index]={glyphs:e.glyphMosaicItems,rtl:h,index:i.index}})),t=!0}i.set(e,r),t&&this._markUsed(a,o)}return i}};w=t([r("esri.views.2d.layers.features.processors.SymbolProcessor")],w);var k=w;export default k;
