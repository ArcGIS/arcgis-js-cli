import{i as e,bg as t,D as i,R as s,S as r,bh as a,a as n,H as o,t as l,aY as d,a$ as u,b0 as f,k as h,aL as c,aZ as p,bD as y,bd as m,x,ay as g,j as _,bE as v,g as D,b4 as b,bF as B,al as L,v as T}from"../main.js";import{o as F,p as R,K as w,A as C,B as O,C as z,D as I,N as M,r as A}from"./definitions-5e24d82a.js";import{i as S,r as k}from"./RenderingContext-81847018.js";import{b as j,I as V,E,R as P,D as U,X as K,C as q,K as G,H as Q,G as H,P as N,S as Z}from"./Utils-b46864a6.js";import{e as X,n as Y,l as W}from"./CircularArray-e829d2b1.js";import{i as $}from"./VertexArrayObject-17b5c9bd.js";import{r as J}from"./mat4f32-a7ddfa75.js";import{a as ee,b as te,e as ie,f as se,r as re,s as ae}from"./VertexBuffer-06b50273.js";import{r as ne,d as oe}from"./TileContainer-59d09056.js";class le{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(e){return this._byGeometryType?this._byGeometryType[e].vertices:0}indicesFor(e){return this._byGeometryType?this._byGeometryType[e].indices:0}needMore(e,t,i){if(!t&&!i)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const s=this._byGeometryType[e];s.vertices+=t,s.indices+=i}}class de{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const e=new de;for(let t=0;t<this.geometries.length;t++){const i=this.geometries[t],s=e.geometries[t];s.indexBuffer=i.indexBuffer.slice(),s.vertexBuffer={};for(const e in i.vertexBuffer){const{data:t,stride:r}=i.vertexBuffer[e];s.vertexBuffer[e]={data:t.slice(),stride:r}}}return e}static deserialize(e){const t=new de;for(let i=0;i<5;++i){t.geometries[i].indexBuffer=new Uint32Array(e.geometries[i].indexBuffer),t.geometries[i].vertexBuffer={};for(const s in e.geometries[i].vertexBuffer)t.geometries[i].vertexBuffer[s]={data:j(e.geometries[i].vertexBuffer[s].data,e.geometries[i].vertexBuffer[s].stride),stride:e.geometries[i].vertexBuffer[s].stride}}return t}serialize(){const e={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let t=0;t<5;++t)for(const i in this.geometries[t].vertexBuffer)e.geometries[t].vertexBuffer[i]={data:this.geometries[t].vertexBuffer[i].data.buffer,stride:this.geometries[t].vertexBuffer[i].stride};return e}getBuffers(){const e=[];for(let t=0;t<5;++t){e.push(this.geometries[t].indexBuffer.buffer);for(const i in this.geometries[t].vertexBuffer)e.push(this.geometries[t].vertexBuffer[i].data.buffer)}return e}}const ue=e.getLogger("esri.views.2d.engine.webgl.WGLDisplayList");function fe(e,t,i,...s){t<e.length?e.splice(t,i,...s):e.push(...s)}const he=new Map;he.set(V.MAP,[E.FILL,E.LINE,E.MARKER,E.TEXT]),he.set(V.LABEL,[E.LABEL]),he.set(V.LABEL_ALPHA,[E.LABEL]);class ce{constructor(e=!1){this.symbolLevels=[],this.unified=e}replay(e,t,i){if(this.unified)for(const s of this.symbolLevels)for(const r of s.zLevels){const s=r.geometryDPInfo.unified;if(s)for(const r of s){const s=e.painter.getGeometryBrush(r.geometryType),a=t.getGeometry(r.geometryType);s.prepareState(e,t),s.drawGeometry(e,t,r,a,i)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(e,t){if(Array.isArray(e))for(const i of e)this._addToList(i,t);else this._addToList(e,t)}removeFromList(e){Array.isArray(e)||(e=[e]);let t=null;for(const i of e)t=this._removeFromList(i);return t}byType(e,t){for(const i of this.symbolLevels)for(const s of i.zLevels){const i=s.geometryDPInfo,r=this.getDPInfoType(e);if(i[r])for(const e of i[r])t(e)}}clone(){const e=new ce(this.unified);for(const t of this.symbolLevels)e.symbolLevels.push(t.clone());return e}splitAfter(e){const t=this._getDisplayList(e.symbolLevel,e.zOrder,e.geometryType),i=t.length,s=e.indexFrom+e.indexCount;for(let r=0;r<i;++r){const i=t[r];if(i.geometryType===e.geometryType&&s>i.indexFrom&&s<=i.indexFrom+i.indexCount){if(s<i.indexFrom+i.indexCount){const e=new pe;e.geometryType=i.geometryType,e.materialKey=i.materialKey,e.indexFrom=s,e.indexCount=i.indexFrom+i.indexCount-s,t.splice(r+1,0,e),i.indexCount=s-i.indexFrom}return r}}}_addToList(e,t){const i=e.symbolLevel,s=e.zOrder,r=this._getDisplayList(i,s,e.geometryType),a=null!=t?t:r.length-1,n=a>=0&&a<r.length?r[a]:null;if(null===n||n.materialKey!==e.materialKey||n.indexFrom+n.indexCount!==e.indexFrom||this.unified&&n.geometryType!==e.geometryType){const t=new pe;t.indexFrom=e.indexFrom,t.indexCount=e.indexCount,t.materialKey=e.materialKey,t.geometryType=e.geometryType,fe(r,a+1,0,t)}else n.indexCount+=e.indexCount}_removeFromList(e){const t=e.symbolLevel,i=e.zOrder,s=this._getDisplayList(t,i,e.geometryType),r=s.length;let a=void 0;for(let t=0;t<r;++t){const i=s[t];if(e.indexFrom+e.indexCount>i.indexFrom&&e.indexFrom<i.indexFrom+i.indexCount&&(!this.unified||i.geometryType===e.geometryType)){a=t;break}}if(void 0!==a){const t=s[a];if(e.indexFrom===t.indexFrom)return t.indexCount-=e.indexCount,t.indexFrom+=e.indexCount,0===t.indexCount&&fe(s,a,1),a-1;if(e.indexFrom+e.indexCount===t.indexFrom+t.indexCount)return t.indexCount-=e.indexCount,0===t.indexCount?(fe(s,a,1),a-1):a;{const i=t.indexFrom,r=e.indexFrom-t.indexFrom,n=e.indexCount,o=t.indexFrom+t.indexCount-(e.indexFrom+e.indexCount);t.indexCount=r;const l=new pe;return l.geometryType=t.geometryType,l.materialKey=t.materialKey,l.indexFrom=i+r+n,l.indexCount=o,fe(s,a+1,0,l),a}}return null}_getDisplayList(e,t,i){let s;const r=this.symbolLevels.length;for(let t=0;t<r;t++)if(this.symbolLevels[t].symbolLevel===e){s=this.symbolLevels[t];break}let a;s||(s=new xe,s.symbolLevel=e,this.symbolLevels.push(s));const n=s.zLevels.length;for(let e=0;e<n;e++)if(s.zLevels[e].zLevel===t){a=s.zLevels[e];break}let o;if(a||(a=new me,a.geometryDPInfo=new ye,a.zLevel=t,s.zLevels.push(a)),this.unified)a.geometryDPInfo.unified||(a.geometryDPInfo.unified=[]),o=a.geometryDPInfo.unified;else switch(i){case E.FILL:a.geometryDPInfo.fill||(a.geometryDPInfo.fill=[]),o=a.geometryDPInfo.fill;break;case E.LINE:a.geometryDPInfo.line||(a.geometryDPInfo.line=[]),o=a.geometryDPInfo.line;break;case E.MARKER:a.geometryDPInfo.marker||(a.geometryDPInfo.marker=[]),o=a.geometryDPInfo.marker;break;case E.TEXT:a.geometryDPInfo.text||(a.geometryDPInfo.text=[]),o=a.geometryDPInfo.text;break;case E.LABEL:a.geometryDPInfo.label||(a.geometryDPInfo.label=[]),o=a.geometryDPInfo.label;break;default:console.error("Trying to add a record with geometry type '"+i+"'.")}return o}getDPInfoType(e){if(this.unified)return"unified";switch(e){case E.FILL:return"fill";case E.LINE:return"line";case E.MARKER:return"marker";case E.TEXT:return"text";case E.LABEL:return"label";default:return void ue.error("DisplayList: Tried to convert unknown geometryType: "+e)}}}class pe{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const e=new pe;return e.geometryType=this.geometryType,e.materialKey=this.materialKey,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e}}class ye{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const e=new ye;return e.fill=this.fill&&this.fill.map((e=>e.clone())),e.line=this.line&&this.line.map((e=>e.clone())),e.marker=this.marker&&this.marker.map((e=>e.clone())),e.text=this.text&&this.text.map((e=>e.clone())),e.label=this.label&&this.label.map((e=>e.clone())),e.unified=this.unified&&this.unified.map((e=>e.clone())),e}}class me{constructor(){this.geometryDPInfo=new ye}clone(){const e=new me;return e.zLevel=this.zLevel,e.geometryDPInfo=this.geometryDPInfo.clone(),e}}class xe{constructor(){this.zLevels=[]}clone(){const e=new xe;e.symbolLevel=this.symbolLevel;for(const t of this.zLevels)e.zLevels.push(t.clone());return e}}function ge(e){const t=[[],[],[],[],[]],i=e;for(const e of i)for(const i of e.displayRecords)t[i.geometryType].push(i);return t}class _e{constructor(){}get hasRegistry(){return!!this._displayObjectRegistry}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const e of this.displayObjects)this._displayObjectRegistry.set(e.id,e)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(e){if(this._displayList=new ce(e),e)for(const e of this.displayObjects)for(const t of e.displayRecords)this._displayList.addToList(t);else{const e=ge(this.displayObjects),t=e.length;for(let i=0;i<t;++i){const t=e[i];this._displayList.addToList(t)}}}clone(){const e=new _e;return this.displayObjects&&(e.displayObjects=this.displayObjects.map((e=>e.clone()))),e}serialize(e){return ee(e,this.displayObjects),e}_deserializeObjects(e){const t=e.readInt32(),i=new Array(t),s=new Map;for(let t=0;t<i.length;++t){const r=te.deserialize(e);i[t]=r,s.set(r.id,r)}this.displayObjects=i,this._displayList=null,this._displayObjectRegistry=s}static deserialize(e){const t=new _e;return t._deserializeObjects(e),t}}const ve=new le,De=new le;function be(e,t){const i={};for(const s in e){const r={data:P(t,e[s]),stride:e[s]};i[s]=r}return i}class Be{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){ve.reset();const e=ge(this.tileDisplayData.displayObjects);for(const t of e)for(const e of t)e&&ve.needMore(e.geometryType,e.meshData?e.meshData.vertexCount:e.vertexCount,e.meshData?e.meshData.indexData.length:e.indexCount);const t=e.length,i=new de;for(let e=0;e<t;++e){i.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*ve.indicesFor(e)));const t=[];for(const i in this.tileBufferData.geometries[e].vertexBuffer)t.push(this.tileBufferData.geometries[e].vertexBuffer[i].stride);const s=Be._computeVertexAlignment(t),r=Math.round(1.5*ve.verticesFor(e)),a=Be._align(r,s);for(const t in this.tileBufferData.geometries[e].vertexBuffer){const s=this.tileBufferData.geometries[e].vertexBuffer[t].stride;i.geometries[e].vertexBuffer[t]={stride:s,data:P(a,s)}}}De.reset(),this.tileDisplayData.displayList.clear();for(let s=0;s<t;++s){const t=e[s];for(const e of t){if(e.meshData)e.writeMeshDataToBuffers(De.verticesFor(s),i.geometries[s].vertexBuffer,De.indicesFor(s),i.geometries[s].indexBuffer),e.meshData=null;else{const t=this.tileBufferData.geometries[s].vertexBuffer,r=this.tileBufferData.geometries[s].indexBuffer,a=i.geometries[s].vertexBuffer,n=i.geometries[s].indexBuffer,o=De.verticesFor(s),l=De.indicesFor(s);U(o,l,a,n,e,t,r),e.vertexFrom=o,e.indexFrom=l}De.needMore(s,e.vertexCount,e.indexCount)}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(t)}if(this.tileDisplayData.displayList.unified)for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=i}reshuffleV2(e,t,i){const s=e.addOrUpdate.tileDisplayData.displayObjects,r=this.tileDisplayData.displayObjects;ve.reset();for(let e=0;e<r.length;e++){const t=r[e];for(let e=0;e<t.displayRecords.length;e++){const i=t.displayRecords[e];ve.needMore(i.geometryType,i.vertexCount,i.indexCount)}}for(let e=t;e<s.length;e++){const r=s[e];for(let s=e===t?i:0;s<r.displayRecords.length;s++){const e=r.displayRecords[s];ve.needMore(e.geometryType,e.vertexCount,e.indexCount)}}const a=new de;for(let e=0;e<5;e++){a.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*ve.indicesFor(e)));const t=[],i=this.tileBufferData.geometries[e].vertexBuffer;for(const e in i)t.push(i[e].stride);const s=Be._computeVertexAlignment(t),r=Math.round(1.5*ve.verticesFor(e)),n=Be._align(r,s);for(const t in i){const s=i[t].stride,r=P(n,s);a.geometries[e].vertexBuffer[t]={stride:s,data:r}}}De.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<r.length;e++){const t=r[e];for(let e=0;e<t.displayRecords.length;e++){const i=t.displayRecords[e],s=i.geometryType,r=this.tileBufferData.geometries[s].vertexBuffer,n=this.tileBufferData.geometries[s].indexBuffer,o=a.geometries[s].vertexBuffer,l=a.geometries[s].indexBuffer,d=De.verticesFor(s),u=De.indicesFor(s);U(d,u,o,l,i,r,n),i.vertexFrom=d,i.indexFrom=u,De.needMore(s,i.vertexCount,i.indexCount),this.tileDisplayData.displayList.addToList(i)}}if(0!==i){const e=s[t];for(let t=0;t<i;t++){const i=e.displayRecords[t],s=i.geometryType,r=this.tileBufferData.geometries[s].vertexBuffer,n=this.tileBufferData.geometries[s].indexBuffer,o=a.geometries[s].vertexBuffer,l=a.geometries[s].indexBuffer,d=De.verticesFor(s),u=De.indicesFor(s);U(d,u,o,l,i,r,n),i.vertexFrom=d,i.indexFrom=u,De.needMore(s,i.vertexCount,i.indexCount),this.tileDisplayData.displayList.addToList(i)}}for(let r=t;r<s.length;r++){const n=s[r];for(let s=r===t?i:0;s<n.displayRecords.length;s++){const t=n.displayRecords[s],i=t.geometryType,r=e.addOrUpdate.tileBufferData.geometries[i],o=r.vertexBuffer,l=r.indexBuffer,d=a.geometries[i].vertexBuffer,u=a.geometries[i].indexBuffer,f=De.verticesFor(i),h=De.indicesFor(i);U(f,h,d,u,t,o,l),t.vertexFrom=f,t.indexFrom=h,De.needMore(i,t.vertexCount,t.indexCount),this.tileDisplayData.displayList.addToList(t)}this.tileDisplayData.hasRegistry&&this.tileDisplayData.displayObjectRegistry.set(n.id,n),this.tileDisplayData.displayObjects.push(n)}this.tileBufferData=a}getStrides(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const i=this.tileBufferData.geometries[t];e[t]={};for(const s in i.vertexBuffer)e[t][s]=i.vertexBuffer[s].stride}return e}clone(){const e=new Be;return e.tileBufferData=this.tileBufferData.clone(),e.tileDisplayData=this.tileDisplayData.clone(),e}_guessSize(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4);let i=0;for(let s=0;s<t;s++)i=Math.max(i,e[s].displayRecords.length);return 2*(12*e.length+e.length*i*40)}serialize(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),i=this.tileDisplayData.serialize(new ie(Int32Array,this._guessSize())).buffer();return t.push(i),{result:{displayData:i,bufferData:e},transferList:t}}static decode(e){const t=se.deserializeDisplayObjects(e),i={};for(const t in e.vertexBuffersMap)i[t]=re.decode(e.vertexBuffersMap[t]);return Be.fromMeshData({displayObjects:t,vertexBuffersMap:i})}static fromMeshData(e){const t=new Be,i=new _e,s=new de;i.displayObjects=e.displayObjects;for(const t in e.vertexBuffersMap){const i=e.vertexBuffersMap[t];s.geometries[t].indexBuffer=i.indexBuffer,s.geometries[t].vertexBuffer=i.namedBuffers}return t.tileDisplayData=i,t.tileBufferData=s,t}static bind(e,t){const i=new Be;return i.tileDisplayData=e,i.tileBufferData=t,i}static create(e,t){const i=new Be;i.tileDisplayData=new _e,i.tileDisplayData.displayObjects=e;const s=[0,0,0,0,0],r=[0,0,0,0,0],a=[[],[],[],[],[]];for(const t of e)for(const e of t.displayRecords)a[e.geometryType].push(e),s[e.geometryType]+=e.meshData.vertexCount,r[e.geometryType]+=e.meshData.indexData.length;const n=new de,o=function(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}(t);for(let e=0;e<5;e++){const t=new Uint32Array(r[e]),i=be(o[e],s[e]);ae.writeAllMeshDataToBuffers(a[e],i,t),n.geometries[e]={indexBuffer:t,vertexBuffer:i}}return i.tileBufferData=n,i}static _align(e,t){const i=e%t;return 0===i?e:e+(t-i)}static _computeVertexAlignment(e){let t=!1,i=!1;for(const s of e)s%4==2?t=!0:s%4!=0&&(i=!0);return i?4:t?2:1}}function Le(e,t,i){if(!e.allDirty)if(null!=e.from&&null!=e.count){const s=Math.min(e.from,t),r=Math.max(e.from+e.count,t+i)-s;e.from=s,e.count=r}else e.from=t,e.count=i}class Te{constructor(){this._dirties=K((()=>({indices:{from:null,count:null,allDirty:!1}})),(()=>({vertices:{from:null,count:null,allDirty:!1}})))}hasDirty(){for(const e of this._dirties)if(null!==e.data.indices.count||e.data.indices.allDirty)return!0;return!1}markAllClean(){for(const e of this._dirties){e.data.indices.from=null,e.data.indices.count=null,e.data.indices.allDirty=!1;for(const t in e.buffers)e.buffers[t].data.vertices.from=null,e.buffers[t].data.vertices.count=null,e.buffers[t].data.vertices.allDirty=!1}}markAllDirty(){for(const e of this._dirties){e.data.indices.allDirty=!0;for(const t in e.buffers)e.buffers[t].data.vertices.allDirty=!0}}forEach(e){for(let t=0;t<this._dirties.length;++t){const i=this._dirties[t],s={};for(const e in i.buffers){const t=i.buffers[e].data.vertices;(t.allDirty||null!=t.from&&null!=t.count&&t.count>0)&&(s[e]=t)}const r=i.data.indices;let a;a=r.allDirty||null!=r.from&&null!=r.count&&r.count>0?{indices:r,vertices:s}:{indices:null,vertices:s},(a.indices||Object.keys(a).length>0)&&e(a,t)}}markDirtyIndices(e,t,i){Le(this._dirties[e].data.indices,t,i)}markDirtyVertices(e,t,i,s){Le(this._dirties[e].buffers[t].data.vertices,i,s)}}class Fe{constructor(e){this._largestRange=null,this._parent=e,this._updateLargestRange()}get largestRange(){return this._largestRange}rangeCreated(e){(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}rangeResized(e,t){e===this._largestRange?e.count<t&&this._updateLargestRange():(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}findBestRange(e){let t=this._parent._freeHead,i=null;for(;null!==t;)t.count>=e&&(!i||t.count-e<i.count-e)&&(i=t),t=t.next;return i}findAdjacentRanges(e,t){let i=!0,s=!1,r=null,a=this._parent._freeHead;for(;i&&!s;){const n=null!==r?r.from+r.count:0,o=null!==a?a.from:this._parent._size;e>=n&&e+t<=o?(i=!1,s=!0):null!==a?(r=a,a=a.next):i=!1}return[r,a]}_updateLargestRange(){let e=null,t=this._parent._freeHead;for(;null!==t;)(!e||t.count>e.count)&&(e=t),t=t.next;this._largestRange=e}}class Re{constructor(e,t){this._allocated=0,this._size=e,this._freeHead=e>0?{from:0,count:e,prev:null,next:null}:null,this._bookKeeper=t||new Fe(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(e){const t=this._bookKeeper.findBestRange(e);if(null===t)return-1;const i=t.from,s=t.count;if(t.from+=e,t.count-=e,this._bookKeeper.rangeResized(t,i,s),this._allocated+=e,0===t.count){const e=null!==t.prev?this._freeHead:t.next;Re._removeRange(t),this._freeHead=e}return i}free(e,t){const[i,s]=this._bookKeeper.findAdjacentRanges(e,t),r={from:e,count:t,prev:i,next:s};if(null!==i&&(i.next=r),null!==s&&(s.prev=r),this._bookKeeper.rangeCreated(r),this._allocated-=t,null!==s&&r.from+r.count===s.from){const e=r.from,t=r.count;Re._fuse(r,s),Re._removeRange(s),this._bookKeeper.rangeResized(r,e,t),this._bookKeeper.rangeResized(s,void 0,0)}if(null!==i&&i.from+i.count===r.from){const e=i.from,t=i.count;Re._fuse(i,r),Re._removeRange(r),this._bookKeeper.rangeResized(i,e,t),this._bookKeeper.rangeResized(r,void 0,0)}this._freeHead=null!==r.prev?this._freeHead:r}get fragmentation(){const e=this._size-this._allocated;return 0===e?0:1-this._bookKeeper.largestRange.count/e}static _removeRange(e){null!==e.prev?null!==e.next?(e.prev.next=e.next,e.next.prev=e.prev):e.prev.next=null:null!==e.next&&(e.next.prev=null)}static _fuse(e,t){e.count+=t.count,e.next=t.next,t.from+=t.count,t.count=0,null!==t.next&&(t.next.prev=e)}}const we=["FILL","LINE","MARKER","TEXT","LABEL"];class Ce{constructor(e,t,i,s){this._strides=e,this._displayList=t,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=i;for(const t in e){this._freeListsAndStorage[t]={vtxFreeList:s?new Re(s):null,idxFreeList:s?new Re(s):null,vertexBuffers:{},indexBuffer:s?new Uint32Array(s):null};for(const i in e[t])this._freeListsAndStorage[t].vertexBuffers[i]={data:s?P(s,e[t][i]):null,stride:e[t][i]}}}static fromTileData(e,t){const i=function(e){const t=e.getStrides(),i={};for(let e=0;e<t.length;e++)i[we[e]]=t[e];return i}(e),s=[0,0,0,0,0],r=[0,0,0,0,0],a=e.tileDisplayData.displayObjects;for(const e of a)for(const t of e.displayRecords)s[t.geometryType]=Math.max(s[t.geometryType],t.vertexFrom+t.vertexCount),r[t.geometryType]=Math.max(r[t.geometryType],t.indexFrom+t.indexCount);const n=new Ce(i,e.tileDisplayData.displayList,t,null);for(let t=0;t<e.tileBufferData.geometries.length;++t){const i=s[t],a=r[t],o=e.tileBufferData.geometries[t],l=we[t],d=n._storageFor(l),u=e.tileBufferData.geometries[t].indexBuffer;let f;d.indexBuffer=u,d.idxFreeList=new Re(u.length),d.idxFreeList.allocate(a);for(const i in o.vertexBuffer){const s=e.tileBufferData.geometries[t].vertexBuffer[i];d.vertexBuffers[i].data=s.data,d.vertexBuffers[i].stride=s.stride;const r=q(s.stride),a=s.data.length*r/s.stride;f||(f=a)}d.vtxFreeList=new Re(f),d.vtxFreeList.allocate(i)}return n}delete(e){const t=we[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0}setMeshData(e,t,i,s,r){const a=we[e.geometryType];e.meshData=null;let n=void 0,o=void 0;void 0===e.vertexFrom?(o=t.vertexCount,n=this._allocateVertices(a,o)):t.vertexCount>e.vertexCount?(this._freeVertices(a,e.vertexFrom,e.vertexCount),o=t.vertexCount,n=this._allocateVertices(a,o)):t.vertexCount===e.vertexCount?(n=e.vertexFrom,o=e.vertexCount):(this._freeVertices(a,e.vertexFrom+t.vertexCount,e.vertexCount-t.vertexCount),n=e.vertexFrom,o=t.vertexCount);let l=!0,d=void 0,u=void 0,f=void 0;if(void 0===e.indexFrom?(d=r,f=t.indexCount,u=this._allocateIndices(a,f)):t.indexCount>e.indexCount?(d=this._displayList.removeFromList(e),this._freeIndices(a,e.indexFrom,e.indexCount),f=t.indexCount,u=this._allocateIndices(a,f)):t.indexCount===e.indexCount?(l=!1,u=e.indexFrom,f=e.indexCount):(d=this._displayList.removeFromList(e),this._freeIndices(a,e.indexFrom+t.indexCount,e.indexCount-t.indexCount),u=e.indexFrom,f=t.indexCount),-1!==n&&-1!==u){const r=this._storageFor(a);if(U(n,u,r.vertexBuffers,r.indexBuffer,t,i,s),e.vertexFrom=n,e.indexFrom=u,e.vertexCount=t.vertexCount,e.indexCount=t.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in i)this._dirtyMap.markDirtyVertices(e.geometryType,t,e.vertexFrom,e.vertexCount)}return l&&this._displayList.addToList(e,d),!0}return-1!==n&&this._freeVertices(a,n,o),-1!==u&&this._freeIndices(a,u,f),e.setMeshDataFromBuffers(t,i,s),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1}tryAddMeshData(e,t){const i=t.vertexBuffer,s=t.indexBuffer,r=we[e.geometryType],a=this._allocateVertices(r,e.vertexCount);if(-1===a)return this._freeVertices(r,a,e.vertexCount),!1;const n=this._allocateIndices(r,e.indexCount);if(-1===n)return this._freeVertices(r,a,e.vertexCount),this._freeIndices(r,n,e.indexCount),!1;const o=this._storageFor(r);if(U(a,n,o.vertexBuffers,o.indexBuffer,e,i,s),e.vertexFrom=a,e.indexFrom=n,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in i)this._dirtyMap.markDirtyVertices(e.geometryType,t,a,e.vertexCount)}return this._displayList.addToList(e),!0}_allocateVertices(e,t){const i=this._storageFor(e),s=i.vtxFreeList.allocate(t);return-1===s||i.vtxFreeList.fragmentation>.5?-1:s}_freeVertices(e,t,i){this._storageFor(e).vtxFreeList.free(t,i)}_freeIndices(e,t,i){this._storageFor(e).idxFreeList.free(t,i)}_allocateIndices(e,t){const i=this._storageFor(e),s=i.idxFreeList.allocate(t);return-1===s||i.idxFreeList.fragmentation>.5?-1:s}_storageFor(e){return this._freeListsAndStorage[e]}_stridesFor(e,t){return this._strides[e][t]}}class Oe{constructor(e=400){this.duration=e,this._lastTime=0,this._elapsed=0,this._value=0,this._finished=!1}get value(){return this._value}reset(){this._lastTime=0,this._elapsed=0,this._value=0}step(){const e=performance.now();if(0===this._lastTime)return this._lastTime=e,this._value=0,!0;if(this._elapsed>=this.duration)return!0;const t=e-this._lastTime;return this._elapsed+=t,this._lastTime=e,this._value=Math.min(this._elapsed/this.duration,1),!1}}class ze{constructor(e){this.geometryMap=K((()=>({indexBuffer:$.createIndex(e,35044),vao:null})),((t,i)=>({vertexBuffer:$.createVertex(e,G[i])})))}dispose(){for(let e=0;e<5;e++){const t=this.geometryMap[e];if(t){t.data.vao&&t.data.vao.dispose(!1),t.data.indexBuffer&&t.data.indexBuffer.dispose();for(const e in t.buffers)t.buffers[e]&&t.buffers[e].data.vertexBuffer.dispose()}}}get(e){const t=this.geometryMap[e],i={};for(const e in t.buffers)i[e]=t.buffers[e].data.vertexBuffer;return{indexBuffer:t.data.indexBuffer,get vao(){return t.data.vao},set vao(e){t.data.vao=e},vertexBufferMap:i}}has(e){return null!=this.geometryMap[e]}upload(e,t){t.forEach(((t,i)=>{this._upload(t,i,e)}))}_upload(e,t,i){if(e.indices&&(e.indices.allDirty?this._uploadIndices(i,t):null!=e.indices.from&&null!=e.indices.count&&this._uploadIndices(i,t,e.indices.from,e.indices.count)),e.vertices){const s=e.vertices;for(const e in s){const r=s[e];r.allDirty?this._uploadVertices(i,t,e):null!=r.from&&null!=r.count&&this._uploadVertices(i,t,e,r.from,r.count)}}}_uploadVertices(e,t,i,s,r){const a=this.geometryMap[t];if(!a)return;const n=e.geometries[t].vertexBuffer[i];if(!n)return;const o=n.stride,l=n.data.buffer;a.buffers[i]&&l.byteLength>0&&(null!=s&&null!=r?a.buffers[i].data.vertexBuffer.setSubData(l,s*o,s*o,(s+r)*o):a.buffers[i].data.vertexBuffer.setData(l))}_uploadIndices(e,t,i,s){const r=this.geometryMap[t];if(!r)return;const a=e.geometries[t].indexBuffer.buffer;r.data.indexBuffer&&a.byteLength>0&&(null!=i&&null!=s?r.data.indexBuffer.setSubData(a,4*i,4*i,4*(i+s)):r.data.indexBuffer.setData(a))}}const Ie=new Set;class Me extends ne{constructor(e,i,s=!1){super(e,i,[F,F]),this._data=null,this._displayList=null,this._wglBuffers=null,this._deferPatches=!1,this._dirtyMap=new Te,this._labelIndex=null,this._lastCommitTime=0,this._patchQueue=new X(100),this.fader=new Oe,this._dirty=!0,this._replaceBuffers=!1,this._uploadsLocked=!1,this._hasData=!1,this._invalidated=!1,this.transforms.labelMat2d=t(),this._ensureCorrectZOrder=s,this._deferPatches=!s}destroy(){super.destroy(),this.clear()}get displayObjects(){var e;return null!=(e=this._displayObjects)?e:[]}get isDirty(){return this._dirty}get hasData(){return!!this._hasData}get labelIndex(){return this._labelIndex}set isDirty(e){this._dirty=e,this.requestRender()}getGeometry(e){return this._wglBuffers&&this._wglBuffers.has(e)?this._wglBuffers.get(e):null}getDisplayList(){return this._displayList}setTransform(e,t){super.setTransform(e,t);const n=this.transforms.labelMat2d,l=e.getScreenTransform(n,t),d=o();i(d,this.coords,l),s(n),r(n,n,d),a(n,e.viewMat2d,n)}setData(e){const t=e.addOrUpdate,i=e.remove;e.clear&&(this.clear(),this._patchQueue.clear(),this._hasData=!1),"replace"===e.type&&(this._replaceBuffers=!0,this._patchQueue.clear(),this._data=null),!this._data&&t&&t.tileDisplayData.displayObjects.length?(t.tileDisplayData.computeDisplayList(this._ensureCorrectZOrder),this._dirtyMap=new Te,this._dispRecStore=Ce.fromTileData(t,this._dirtyMap),this._data=t,this._dirtyMap.markAllDirty(),this._hasData=!0,e.end&&this.ready()):this._data&&(t&&t.tileDisplayData.displayObjects.length||i.length)?this._deferPatches?this._patchQueue.enqueue(e):this._doPatchData(e):e.end&&this.ready(),e.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}lockUploads(){this._uploadsLocked=!0}unlockUploads(){this._uploadsLocked=!1,this.requestRender()}commitChanges(e){if(!e.time||e.time!==this._lastCommitTime){if(this._lastCommitTime=e.time,this.fader.step()||this.requestRender(),this._patchQueue.size){const e=this._patchQueue.dequeue();n(e)&&(e.end&&this.ready(),this._doPatchData(e),this.requestRender(),this._hasData=!0)}if(this._uploadsLocked)this.requestRender();else if(this.visible&&this._data){if(this._replaceBuffers)for(this._wglBuffers&&this._wglBuffers.dispose(),this._wglBuffers=null,this._replaceBuffers=!1;this._patchQueue.size;){const e=this._patchQueue.dequeue();n(e)&&(e.end&&this.ready(),this._doPatchData(e),this._hasData=!0)}this._wglBuffers||(this._wglBuffers=new ze(e.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._rebuildLabelIndex(),this._dirtyMap.markAllClean())}}}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(e){try{if("new"===e.type){if(!e.addOrUpdate)return;this._invalidated=!0;const t=this._bulkAddFeatures(e);t&&(this._dirtyMap.markAllDirty(),this._data.reshuffleV2(e,t.objectIndex,t.recordIndex),this._dispRecStore=Ce.fromTileData(this._data,this._dirtyMap))}else this._invalidated=!0,this._patchData(e)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=Ce.fromTileData(this._data,this._dirtyMap))}catch(e){}this.requestRender()}_rebuildLabelIndex(){var e,t;if(null==(e=this._data)||null==(t=e.tileBufferData.geometries[E.LABEL])?void 0:t.indexBuffer.length){this.isDirty=!0,this._labelIndex=this._initLabelIndex();for(const e of this.displayObjects)for(const t of e.metrics)this._insertIntoLabelIndex(t)}}_insertIntoLabelIndex(e){e.xBucket<0||e.yBucket<0||e.yBucket>3||e.xBucket>3||this.labelIndex[e.yBucket][e.xBucket].push(e)}_initLabelIndex(){const e=[];for(let t=0;t<F/R;t++){e.push([]);for(let i=0;i<F/R;i++)e[t].push([])}return e}_bulkAddFeatures(e){const t=e.addOrUpdate.tileDisplayData.displayObjects,i=this._data.tileDisplayData.displayObjects;for(let s=0;s<t.length;s++){const r=t[s];for(let t=0;t<r.displayRecords.length;++t){const i=r.displayRecords[t],a=e.addOrUpdate.tileBufferData.geometries[i.geometryType];if(!this._dispRecStore.tryAddMeshData(i,a))return{objectIndex:s,recordIndex:t}}this._data.tileDisplayData.hasRegistry&&this._data.tileDisplayData.displayObjectRegistry.set(r.id,r),i.push(r)}return null}_patchData(e){let t=!0;const i=e.addOrUpdate&&e.addOrUpdate.tileDisplayData&&e.addOrUpdate.tileDisplayData.displayObjects||[],s=(e.remove||[]).slice();for(const e of i)null!=e.insertAfter&&s.push(e.id);for(const e of s){const t=this._data.tileDisplayData.displayObjectRegistry.get(e);if(t){this._data.tileDisplayData.displayList.removeFromList(t.displayRecords);for(const e of t.displayRecords)this._dispRecStore.delete(e);this._data.tileDisplayData.displayObjectRegistry.delete(e);const i=this._data.tileDisplayData.displayObjects.indexOf(t);this._data.tileDisplayData.displayObjects.splice(i,1)}}for(const s of i){let i,r=this._data.tileDisplayData.displayObjectRegistry.get(s.id);if(r){const e=r.displayRecords;r.set(s),r.displayRecords=e;const t=r.displayRecords.length;for(let e=0;e<t;++e){const t=r.displayRecords[e],i=s.displayRecords[e];(e>=s.displayRecords.length||t.geometryType!==i.geometryType||t.symbolLevel!==i.symbolLevel||t.zOrder!==i.zOrder||t.materialKey!==i.materialKey)&&(this._dispRecStore.delete(r.displayRecords[e]),e<s.displayRecords.length&&(r.displayRecords[e]=void 0))}r.displayRecords.length=s.displayRecords.length,r.metrics=s.metrics}else{let e;r=s.copy(),r.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(s.id,r);const t=this._data.tileDisplayData.displayObjects;if(null!=r.insertAfter)if(i={},r.insertAfter>=0){const i=this._data.tileDisplayData.displayObjectRegistry.get(r.insertAfter);i?(e=t.indexOf(i)+1,e<t.length?t.splice(e,0,r):(t.push(r),e=t.length)):(t.push(r),e=t.length)}else t.unshift(r),e=0;else t.push(r),e=t.length;if(i){let r;if(this._data.tileDisplayData.displayList.unified)r=s.displayRecords.length>0?1:0;else{Ie.clear();for(const e of s.displayRecords){const t=this._data.tileDisplayData.displayList.getDPInfoType(e.geometryType);Ie.add(t)}r=Ie.size}let a=0;for(let s=e-1;s>=0&&a<r;--s)for(let e=t[s].displayRecords.length-1;e>=0&&a<r;--e){const r=t[s].displayRecords[e],n=this._data.tileDisplayData.displayList.getDPInfoType(r.geometryType);i[n]||(i[n]=r,++a)}}}const a=s.displayRecords.length;for(let n=0;n<a;++n){const a=s.displayRecords[n];let o=r.displayRecords[n];o?(o.meshData=a.meshData,o.materialKey=a.materialKey):(o=a.copy(),o.vertexFrom=void 0,o.indexFrom=void 0,r.displayRecords[n]=o);const l=a.geometryType,d=this._data.tileDisplayData.displayList.getDPInfoType(l),u=e.addOrUpdate.tileBufferData.geometries[l],f=u.vertexBuffer,h=u.indexBuffer;let c=void 0;i&&(c=i[d]?this._data.tileDisplayData.displayList.splitAfter(i[d]):-1),t=this._dispRecStore.setMeshData(o,a,f,h,c)&&t,i&&null!=o.indexFrom&&null!=o.indexFrom&&(i[d]=o)}}return t}}const Ae=e.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),Se=Y(W,Ae),ke=e=>2147483647&e;class je{constructor(e,t,i){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:s,pixelType:r,textureOnly:a}=e,n=Q(r);this.shared=i,this.pixelType=r,this.size=t,this.textureOnly=a,a||(this.data=new n(f(s))),this._resetRange()}destroy(){u(this._texture,(e=>e.dispose()));for(const e in this._fbos)u(this._fbos[e],(t=>{"0"===e&&t.detachColorTexture(),t.dispose()})),this._fbos[e]=null;this._texture=null}get _textureDesc(){return{target:3553,wrapMode:33071,pixelFormat:6408,dataType:this.pixelType,samplingMode:9728,width:this.size,height:this.size}}setData(e,t,i){const s=ke(e),r=f(this.data),a=s*this.texelSize+t;!r||a>=r.length||(r[a]=i,this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,s))}getData(e,t){if(l(this.data))return null;const i=ke(e)*this.texelSize+t;return!this.data||i>=this.data.length?null:this.data[i]}getTexture(e){return m(this._texture,(()=>this._initTexture(e)))}getFBO(e,t=0){if(l(this._fbos[t])){const i={colorTarget:0,depthStencilTarget:0},s=0===t?this.getTexture(e):this._textureDesc;this._fbos[t]=new k(e,i,s)}return this._fbos[t]}get locked(){return!(5121!==this.pixelType||!this.shared||this.textureOnly||!x("esri-atomics")||!this.data)&&1===Atomics.load(this.data,0)}updateTexture(e){if(!this.locked)try{const t=this.dirtyStart,i=this.dirtyEnd;if(t>i)return;this._resetRange();const s=f(this.data).buffer,r=this.getTexture(e),a=4,n=(t-t%this.size)/this.size,o=(i-i%this.size)/this.size,l=n,d=this.size,u=o,c=n*this.size*a,p=(d+u*this.size)*a-c,y=Q(this.pixelType),m=y.BYTES_PER_ELEMENT;try{new y(s,c*m,p)}catch(e){console.debug(e)}const x=new y(s,c*m,p),g=this.size,_=u-l+1;if(_>this.size)return void Ae.error(new h("mapview-webgl","Out-of-bounds index when updating AttributeData"));r.updateData(0,0,l,g,_,x)}catch(e){console.debug(e)}}update(e){const{data:t,start:i,end:s}=e;if(n(t)){const s=this.data,r=i*this.texelSize;for(let i=0;i<t.length;i++){const a=1<<i%this.texelSize;e.layout&a&&(s[r+i]=t[i])}}this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,s)}resize(e,t){const i=this.size;if(this.size=t,this.textureOnly)return void(i!==this.size&&(this._lastTexture=this._texture,this._texture=null));const s=Q(this.pixelType);this.destroy(),this.data=new s(f(e.buffer))}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(e){const t=new S(e,this._textureDesc,m(this.data,void 0));if(n(this._lastTexture)&&this._fbos[0]){const i=this._lastTexture.descriptor.width,s=this._lastTexture.descriptor.height,r=this._lastTexture.descriptor.dataType,a=this._lastTexture.descriptor.pixelFormat,n=this.getFBO(e),o=H(r),l=new(Q(r))(new ArrayBuffer(i*s*o*this.texelSize)),d=e.getBoundFramebufferObject(),{x:u,y:f,width:h,height:c}=e.getViewport();e.bindFramebuffer(n),n.readPixels(0,0,i,s,a,r,l),t.updateData(0,0,0,2*i,s/2,l),e.setViewport(u,f,h,c),e.bindFramebuffer(d)}return this.destroy(),this._texture=t,this._texture}}class Ve{constructor(){this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(e){const{blocks:t,shared:i,size:s}=e;if(this.shared=i,this.size=s,Se("Initializing AttributeStoreView",e),l(this._data))this._data=d(t,(e=>new je(e,s,i)));else for(let e=0;e<this._data.length;e++){const r=this._data[e],a=t[e];n(a)&&(l(r)?this._data[e]=new je(a,s,i):r.resize(a,s))}this._initialized=!0}destroy(){u(this._data,(e=>d(e,(e=>e.destroy())))),u(this._defaultTexture,(e=>e.dispose()))}getBlock(e){return l(this._data)?null:this._data[e]}setLabelMinZoom(e,t){this.setData(e,0,1,t)}getLabelMinZoom(e){return this.getData(e,0,1,255)}getFilterFlags(e){return this.getData(e,0,0,0)}getVVSize(e){return this.getData(e,w,0,0)}getData(e,t,i,s){if(!this._data)return 0;const r=f(this._data)[t];if(l(r))return 0;const a=r.getData(e,i);return n(a)?a:s}setData(e,t,i,s){const r=f(this._data)[t];f(r).setData(e,i,s)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(e){if(this._pendingAttributeUpdate)return void Ae.error(new h("mapview-webgl","Tried to update attribute data with a pending update"));const t=c();return Se("AttributeStoreView Update Requested",e),this._pendingAttributeUpdate={data:e,resolver:t},t.promise}update(){if(this._initialized&&n(this._pendingAttributeUpdate)){const{data:e,resolver:t}=this._pendingAttributeUpdate,i=f(this._data);for(let t=0;t<e.blocks.length;t++){const s=e.blocks[t],r=i[t];u(r,(e=>u(s,(i=>{Se("Updating block "+t,i),e.update(i)}))))}this._pendingAttributeUpdate=null,t()}}bindTextures(e){this.update();const t=this._getDefaultTexture(e);if(!this._initialized)return e.bindTexture(t,C),e.bindTexture(t,O),e.bindTexture(t,z),void e.bindTexture(t,I);const i=f(this._data);this._locked&&!this._forceNextUpload||(p(i,(t=>t.updateTexture(e))),this._forceNextUpload=!1),e.bindTexture(y(i[0],t,(t=>t.getTexture(e))),C),e.bindTexture(y(i[1],t,(t=>t.getTexture(e))),O),e.bindTexture(y(i[2],t,(t=>t.getTexture(e))),z),e.bindTexture(y(i[3],t,(t=>t.getTexture(e))),I)}_getDefaultTexture(e){if(l(this._defaultTexture)){const t={wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1};this._defaultTexture=new S(e,t,new Uint8Array(4))}return this._defaultTexture}}function Ee(e,t){const i=t.length;if(e<t[0].value||1===i)return t[0].size;for(let s=1;s<i;s++)if(e<t[s].value){const i=(e-t[s-1].value)/(t[s].value-t[s-1].value);return t[s-1].size+i*(t[s].size-t[s-1].size)}return t[i-1].size}function Pe(e,t,i=0){if(l(t))return e[i+0]=0,e[i+1]=0,e[i+2]=0,void(e[i+3]=0);const{r:s,g:r,b:a,a:n}=t;e[i+0]=s*n/255,e[i+1]=r*n/255,e[i+2]=a*n/255,e[i+3]=n}const Ue=(e,t,i)=>{const s=16*i;for(let i=s,r=0;i<Math.min(s+16,e.length);i++,r++)e[i]=t[r]},Ke=J();class qe{constructor(){this.symbolLevels=[],this.vvColorValues=new Float32Array(8),this.vvColors=new Float32Array(32),this.vvOpacityValues=new Float32Array(8),this.vvOpacities=new Float32Array(8),this.vvSizeMinMaxValue=new Float32Array(4),this.ddColors=new Float32Array(32),this.ddBackgroundColor=new Float32Array(4),this.ddActiveDots=new Float32Array(8),this.insideEffect=new Float32Array(16*M),this.insideOpacity=1,this.outsideEffect=new Float32Array(16*M),this.outsideOpacity=1,this.effectCount=0,this._vvMaterialParameters={vvSizeEnabled:!1,vvColorEnabled:!1,vvRotationEnabled:!1,vvRotationType:"geographic",vvOpacityEnabled:!1},this._buf0=new Float32Array(2),this._buf1=new Float32Array(2),this.symbolLevels.push(0);for(let e=0;e<M;e++)Ue(this.insideEffect,Ke,e),Ue(this.outsideEffect,Ke,e)}get insideOpacities(){return this._buf0[0]=1,this._buf0[1]=this.insideOpacity,this._buf0}get outsideOpacities(){return this._buf1[0]=0,this._buf1[1]=this.outsideOpacity,this._buf1}getSizeVVFieldStops(e){const t=this._vvSizeFieldStops;switch(t.type){case"static":return t;case"level-dependent":return m(t.levels[e],(()=>{let i=1/0,s=0;for(const r in t.levels){const t=parseFloat(r),a=Math.abs(e-t);a<i&&(i=a,s=t)}if(i===1/0)return{sizes:new Float32Array([0,0,0,0,0,0]),values:new Float32Array([0,0,0,0,0,0])};const r=e-s,a=Math.pow(2,r/2),n=f(t.levels[s]),o=new Float32Array(n.values);return o[2]*=a,o[3]*=a,{sizes:f(n.sizes),values:o}}))}}get vvMaterialParameters(){return this._vvMaterialParameters}update(e){n(this._vvInfo)&&this._updateVisualVariables(this._vvInfo.vvRanges,e)}setInfo(e,t,i){switch(n(i)?(i.forEach(((e,t)=>this._updateEffects(t,e))),this.effectCount=i.length):this.effectCount=0,this._vvInfo=t,e.type){case"dot-density":this._updateDotDensityInfo(e)}}getVariation(){return{ddDotBlending:this.ddDotBlending,outsideLabelsVisible:this.outsideLabelsVisible,effectCount:this.effectCount,oesTextureFloat:g().supportsTextureFloat}}getVariationHash(){return(this.ddDotBlending?1:0)|(this.outsideLabelsVisible?1:0)<<1|this.effectCount<<2}_updateEffects(e,t){const i=e+1;if(n(t)&&t.filter&&t.filter.enabled){this.outsideLabelsVisible=t.excludedLabelsVisible;const{parsedIncludedEffect:e,parsedExcludedEffect:s}=t;n(e)?(Ue(this.insideEffect,e.getColorMatrix(),i),this.insideOpacity=e.getOpacity()):(Ue(this.insideEffect,Ke,i),this.insideOpacity=1),n(s)?(Ue(this.outsideEffect,s.getColorMatrix(),i),this.outsideOpacity=s.getOpacity()):(Ue(this.outsideEffect,Ke,i),this.outsideOpacity=1)}else Ue(this.insideEffect,Ke,i),Ue(this.outsideEffect,Ke,i),this.insideOpacity=1,this.outsideOpacity=1}_updateVisualVariables(e,t){const i=this._vvMaterialParameters;if(i.vvOpacityEnabled=!1,i.vvSizeEnabled=!1,i.vvColorEnabled=!1,i.vvRotationEnabled=!1,!e)return;const s=e.size;if(s){if(i.vvSizeEnabled=!0,s.minMaxValue){const e=s.minMaxValue;let i,r;if(N(e.minSize)&&N(e.maxSize))if(Z(e.minSize)&&Z(e.maxSize))i=_(e.minSize),r=_(e.maxSize);else{const s=t.scale;i=_(Ee(s,e.minSize.stops)),r=_(Ee(s,e.maxSize.stops))}this.vvSizeMinMaxValue.set([e.minDataValue,e.maxDataValue,i,r])}if(s.scaleStops&&(this.vvSizeScaleStopsValue=_(Ee(t.scale,s.scaleStops.stops))),s.unitValue){const e=v(t.spatialReference)/D[s.unitValue.unit];this.vvSizeUnitValueToPixelsRatio=e/t.resolution}s.fieldStops&&(this._vvSizeFieldStops=s.fieldStops)}const r=e.color;r&&(i.vvColorEnabled=!0,this.vvColorValues.set(r.values),this.vvColors.set(r.colors));const a=e.opacity;a&&(i.vvOpacityEnabled=!0,this.vvOpacityValues.set(a.values),this.vvOpacities.set(a.opacities));const n=e.rotation;n&&(i.vvRotationEnabled=!0,i.vvRotationType=n.type)}_updateDotDensityInfo(e){const t=e.attributes;this.ddDotValue=e.dotValue,this.ddDotScale=e.referenceScale,this.ddDotSize=e.dotSize,this.ddDotBlending=e.dotBlendingEnabled,this.ddSeed=e.seed;for(let e=0;e<A;e++){const i=e>=t.length?new b([0,0,0,0]):t[e].color;Pe(this.ddColors,i,4*e)}for(let t=0;t<8;t++)this.ddActiveDots[t]=t<e.attributes.length?1:0;Pe(this.ddBackgroundColor,e.backgroundColor)}}class Ge extends oe{constructor(e){super(e),this._rendererInfo=new qe,this._materialItemsRequestQueue=new B,this.attributeView=new Ve}destroy(){this.removeAllChildren(),this.children.forEach((e=>e.destroy())),this.attributeView.destroy(),this._materialItemsRequestQueue.clear()}setRendererInfo(e,t,i){this._rendererInfo.setInfo(e,t,i),this.requestRender()}async getMaterialItems(e,t){if(!e||0===e.length)return null;const i=c();return this._materialItemsRequestQueue.push({items:e,abortOptions:t,resolver:i}),this.requestRender(),i.promise}onTileData(e,t){if(t.addOrUpdate&&"tileDisplayData"in t.addOrUpdate)e.setData(t);else{const i=t.addOrUpdate&&Be.decode(t.addOrUpdate),s={...t,addOrUpdate:i};e.setData(s)}this.contains(e)||this.addChild(e),this.requestRender()}onTileError(e){e.clear(),this.contains(e)||this.addChild(e)}doRender(e){if(e.context.capabilities.textureFloat,e.context.capabilities.vao,this._materialItemsRequestQueue.length>0){let t=this._materialItemsRequestQueue.pop();for(;t;)this._processMaterialItemRequest(e,t),t=this._materialItemsRequestQueue.pop()}super.doRender(e)}renderChildren(e){for(const t of this.children)t.commitChanges(e);this._rendererInfo.update(e.state),this.attributeView.bindTextures(e.context),super.renderChildren(e)}createTile(e){const t=this._tileInfoView.getTileBounds(L(),e);return new Me(e,t)}destroyTile(e){this.removeChild(e),e.destroy()}createRenderParams(e){return{...super.createRenderParams(e),rendererInfo:this._rendererInfo,attributeView:this.attributeView}}_processMaterialItemRequest(e,{items:t,abortOptions:i,resolver:s}){const{painter:r,pixelRatio:a}=e,n=t.map((e=>r.textureManager.rasterizeItem(e.symbol,a,e.glyphIds,i)));T(n).then((e=>{if(!this.stage)return void s.reject();const i=e.map(((e,i)=>({id:t[i].id,mosaicItem:e})));s.resolve(i)}),s.reject)}}export{Me as D,Be as a,Ge as l};
